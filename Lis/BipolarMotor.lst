C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      01/11/2019 15:45:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BIPOLARMOTOR
OBJECT MODULE PLACED IN .\Obj\BipolarMotor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE BipolarMotor.c LARGE BROWSE INCDIR(.\Application\Header) DEBUG OBJECTEXT
                    -END PRINT(.\Lis\BipolarMotor.lst) TABS(2) OBJECT(.\Obj\BipolarMotor.obj)

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "LCD_Driver_SPLC780D.h"
   3          #include "Receiver_Position_Data.h"
   4          #include "math.h"
   5          #include "SunPos.h"
   6          //#include "PCF85963BTL.h"
   7          void Delay_ms(unsigned int ms);
   8          int Day_Of_Year(unsigned char months,unsigned char days);
   9          unsigned char BCDtoDec1(char bcd);
  10          float  degree;
  11          unsigned char previous_move_time=0;
  12          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
  13                      float  a21, float  a22, float  a23, float  a24,
  14                      float  a31, float  a32, float  a33, float  a34,
  15                      float  a41, float  a42, float  a43, float  a44 );
  16           float  findDet3x3( 
  17                      float  a11, float  a12, float  a13, 
  18                      float  a21, float  a22, float  a23,
  19                      float  a31, float  a32, float  a33 );           
  20          float
  21          cubic_interpolate (float *p1, float *p2, float *p3, float *p4, float x);
  22          
  23          unsigned char BCDtoDec1(unsigned char bcd)
  24          {
  25   1        unsigned char hi,lo;
  26   1        hi=bcd>>4;
  27   1        lo=bcd&0x0F;
  28   1        return hi*10+lo;
  29   1      }
  30          // 
  31          void wait (void)  {                   /* wait function */
  32   1        ;                                   /* only to delay for LED flashes */
  33   1      }
  34          
  35          void vOneStepMove(bit bDir)
  36          {
  37   1        unsigned char temp;
  38   1        temp=P3;
  39   1        if(bDir)
  40   1          {
  41   2            switch(temp){
  42   3             case 0x13: 
  43   3               P3=0x26;
  44   3                break;
  45   3            case 0x26:
  46   3              P3=0x4C;
  47   3              break;
  48   3            case 0x4C:
  49   3              P3=0x89;
  50   3              break;
  51   3            case 0x89:
  52   3              P3=0x13;
  53   3              break;
  54   3          }
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      01/11/2019 15:45:49 PAGE 2   

  55   2        }
  56   1        else
  57   1          {
  58   2            switch(temp){
  59   3            case 0x13:
  60   3              P3=0x89;
  61   3              break;
  62   3            case 0x89:
  63   3              P3=0x4C;
  64   3              break;
  65   3            case 0x4C:
  66   3              P3=0x26;
  67   3              break;
  68   3            case 0x26:
  69   3              P3=0x13;
  70   3              break;
  71   3          }
  72   2        }
  73   1      }
  74          
  75          void Step_move(unsigned int step, bit dir)
  76          {
  77   1      
  78   1            unsigned int i=0;
  79   1            //P3M1=0x00;
  80   1            //P3M0=0xFF;
  81   1            for(i=0;i<step;i++)
  82   1            {
  83   2                    vOneStepMove(dir);
  84   2                    Wait_ms(30);
  85   2            }
  86   1      
  87   1      }
  88          
  89          void Move(float  distance, bit direction)
  90          {
  91   1          unsigned int step;
  92   1          step= (unsigned int)(distance*10/0.3);// from practical, know the number of steps, know the real distanc
             -e => 10 steps ~0.3mm 
  93   1          Step_move(step,direction);
  94   1      }
  95          //=====================================================
  96          //We need 4 points for cubic interpolation, p1[x],p1[y],..,p4[x],p4[y]
  97           float  findDet3x3( 
  98                      float  a11, float  a12, float  a13, 
  99                      float  a21, float  a22, float  a23,
 100                      float  a31, float  a32, float  a33 )
 101          {
 102   1          return( a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
 103   1                  a13*a22*a31 - a12*a21*a33 - a11*a23*a32 );
 104   1      }
 105          float  findDet4x4 (float  a11, float  a12, float  a13, float  a14, 
 106                      float  a21, float  a22, float  a23, float  a24,
 107                      float  a31, float  a32, float  a33, float  a34,
 108                      float  a41, float  a42, float  a43, float  a44 )
 109          {
 110   1        
 111   1          //return a11*(float)findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44);
 112   1          //return (float)findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44);
 113   1          //return (float)findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44);
 114   1          //return (float)findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43);
 115   1        //  return a21;
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      01/11/2019 15:45:49 PAGE 3   

 116   1          return( a11*findDet3x3(a22, a23, a24, a32, a33, a34, a42, a43, a44) -
 117   1                  a12*findDet3x3(a21, a23, a24, a31, a33, a34, a41, a43, a44) +
 118   1                  a13*findDet3x3(a21, a22, a24, a31, a32, a34, a41, a42, a44) -
 119   1                  a14*findDet3x3(a21, a22, a23, a31, a32, a33, a41, a42, a43));
 120   1      }
 121              
 122          //===================================================== 
 123          
 124           
 125          //===================================================== 
 126          float  linear_interpolate(struct point p1,struct point p2, float  x)
 127          {
 128   1        float  fx;
 129   1        
 130   1        fx=-(p1.x-x)/(p1.x-p2.x)*(p1.y-p2.y)+p1.y;
 131   1        
 132   1        return fx;
 133   1      }
 134          
 135          
 136          
 137          void Update_position(unsigned char mnths,unsigned char dys,
 138                               unsigned char hurs,unsigned char mns,unsigned char sconds,
 139                               float  *currnt_pos, float offset_calib)
 140          {
 141   1        unsigned int date,i=0,yy=0;
 142   1        
 143   1        float  desired_distance=0,distance=0,JP_pos=0;
 144   1        float  pos_interpolate_azimuth[num_of_azimuth_stamp],current_local_sun_time,azimuth, elevation,time_offse
             -t,UTC_time=-5;
 145   1        float declination;
 146   1        struct point p1,p2;
 147   1        struct cTime time;
 148   1        struct cLocation location;
 149   1        struct cSunCoordinates *sunCoord;
 150   1        //hurs=hurs-1;// change to sun time
 151   1        //dys=dys+4;
 152   1        location.dLongitude=-73.6495;
 153   1        location.dLatitude=45.478889;
 154   1        time.iYear=2018;
 155   1        time.iMonth=BCDtoDec1(mnths);
 156   1        time.iDay=BCDtoDec1(dys);
 157   1        time.dHours=BCDtoDec1(hurs);
 158   1        time.dMinutes=BCDtoDec1(mns);
 159   1        time.dSeconds=BCDtoDec1(sconds&0x7f);
 160   1      
 161   1        
 162   1        desired_distance=*currnt_pos;
 163   1        
 164   1        //date=Day_Of_Year(mnths,dys)+4;
 165   1        //date=237;
 166   1        declination=sunpos(time,location,&sunCoord)*180/pi;//+declination_offset;
*** WARNING C182 IN LINE 166 OF BipolarMotor.c: pointer to different objects
 167   1        time_offset=1/60*(4*(location.dLongitude-15*UTC_time)+9.87*sin(2*(360*(time.iDay-81)/365)*pi/180)    -   
             - 7.53*cos((360*(time.iDay-81)/365)*pi/180)    -   1.5*sin((360*(time.iDay-81)/365)*pi/180));
 168   1        current_local_sun_time=(float) (BCDtoDec1(hurs))+(float)BCDtoDec1(mns)/60+time_offset-1;//current time=su
             -n time= clock time -1
 169   1        //=B10-1/60*(4*($B$7-15*$B$4)+9.87*SIN(2*(360*($B$8-81)/365)*3.1416/180)    -    7.53*COS((360*($B$8-81)/
             -365)*3.1416/180)    -   1.5*SIN((360*($B$8-81)/365)*3.1416/180))
 170   1        elevation=(180/pi)*asin(             sin(location.dLatitude*pi/180)*sin(declination*pi/180)+
 171   1                  cos(location.dLatitude*pi/180)*cos(declination*pi/180)*cos((15*(current_local_sun_time-12))*pi/180) 
             -          );
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      01/11/2019 15:45:49 PAGE 4   

 172   1        azimuth=180+(180/pi)*asin(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin
             -((90-elevation)*pi/180)          );// JP calculation
 173   1        //azimuth=(180/pi)*acos(       sin((15*(current_local_sun_time-12))*pi/180)*cos(declination*pi/180)/sin((
             -90-elevation)*pi/180)          );// JP calculation
 174   1      
 175   1        
 176   1        //if (current_local_sun_time>12)
 177   1        //  azimuth=360-azimuth;
 178   1        
 179   1        if(BCDtoDec1(sconds&0x7f)%2==0)
 180   1        {
 181   2          // interpolate for azimuth
 182   2          for (i=0;i<num_of_azimuth_stamp;i++)
 183   2          {
 184   3            if ((azimuth<=date_azimuth_mapping[i+1]) && (azimuth>=date_azimuth_mapping[i]))
 185   3            {
 186   4              for (yy=0;yy<num_of_elevation_stamp;yy++)
 187   4              {
 188   5                p1.x=date_azimuth_mapping[i];
 189   5                p2.x=date_azimuth_mapping[i+1];
 190   5                
 191   5                p1.y=RX_pos[yy][i];
 192   5                p2.y=RX_pos[yy][i+1];
 193   5                
 194   5                pos_interpolate_azimuth[yy]=linear_interpolate(p1,p2,azimuth);
 195   5              }
 196   4              //break;
 197   4            }
 198   3          }
 199   2      
 200   2          // interpolate for elevation
 201   2          for(i=0;i<num_of_elevation_stamp;i++)
 202   2          {
 203   3            if((elevation>=elevation_stamp[i])&&(elevation<=elevation_stamp[i+1]))
 204   3            {
 205   4              p1.x=elevation_stamp[i];
 206   4              p2.x=elevation_stamp[i+1];
 207   4              
 208   4              p1.y=pos_interpolate_azimuth[i];
 209   4              p2.y=pos_interpolate_azimuth[i+1];
 210   4              
 211   4              JP_pos=linear_interpolate(p1,p2,elevation);
 212   4              //break;
 213   4              
 214   4            }
 215   3            
 216   3          }
 217   2          
 218   2          desired_distance=27+2*JP_pos +offset_calib;
 219   2          
 220   2          distance=desired_distance-*currnt_pos;
 221   2          if(abs(distance)>0.5 | abs(previous_move_time-BCDtoDec1(sconds&0x7f))>30)// move if the change is more t
             -han 0.5mm OR >30s
 222   2          {
 223   3            if(distance>0)
 224   3              Move(distance,1);
 225   3            else if (distance<0)
 226   3              Move(-distance,0);
 227   3            previous_move_time=BCDtoDec1(sconds&0x7f);
 228   3            *currnt_pos=desired_distance;
 229   3          }
 230   2        }
C51 COMPILER V9.52.0.0   BIPOLARMOTOR                                                      01/11/2019 15:45:49 PAGE 5   

 231   1        return;
 232   1      
 233   1      }
*** WARNING C280 IN LINE 141 OF BipolarMotor.c: 'date': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3577    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    961     304
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
